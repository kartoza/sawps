import React, { useState } from 'react';
import Grid from "@mui/material/Grid";
import Button from "@mui/material/Button";
import CircularProgress from "@mui/material/CircularProgress";
import HelpOutlineOutlinedIcon from '@mui/icons-material/HelpOutlineOutlined';
import LightTooltip from '../../../components/LightTooltip';
import {postData} from "../../../utils/Requests";
import { PropertyInfo } from '../Property';
import PropertyInterface, { PropertyValidation, createNewProperty } from '../../../models/Property';
import AlertMessage from '../../../components/AlertMessage';

import './index.scss';


const PROPERTY_UPDATE_INFORMATION_URL = '/api/property/detail/update/'
const PROPERTY_CHECK_AVAILABLE_NAME_URL = '/api/property/check-available-name/'

interface Step1Interface {
    initialProperty?: PropertyInterface;
    onSave: (data: PropertyInterface) => void
}

export default function Step1(props: Step1Interface) {
    const [savingProperty, setSavingProperty] = useState(false)
    const [property, setProperty] = useState<PropertyInterface>(props.initialProperty ? {...props.initialProperty} : createNewProperty())
    const [propertyValidation, setPropertyValidation] = useState<PropertyValidation>({})
    const [alertMessage, setAlertMessage] = useState<string>('')

    const updatePropertyInformation = () => {
        let _data:PropertyInterface = {
            ...property
        }
        setSavingProperty(true)
        postData(`${PROPERTY_UPDATE_INFORMATION_URL}`, _data).then(
            response => {
                setSavingProperty(false)
                // trigger to next step
                props.onSave({...property})
            }
          ).catch(error => {
            setSavingProperty(false)
            console.log('error ', error)
            alert('Error saving property...')
          })
    }

    const onSaveProperty = () => {
        let _error_messages = []
        let _error_validation = {}
        if (property.name.trim() === '') {
            _error_messages.push('Error! Property name is mandatory!')
            _error_validation = { ..._error_validation, name: true }
        }
        if (property.property_type.trim() === '') {
            _error_messages.push('Error! Property type is mandatory!')
            _error_validation = { ..._error_validation, property_type: true }
        }
        if (property.organisation.trim() === '') {
            _error_messages.push('Error! Organisation is mandatory!')
            _error_validation = { ..._error_validation, organisation: true }
        }
        if (_error_messages.length && !_error_validation) {
            setAlertMessage(_error_messages[0])
            return
        } else if (_error_messages.length === 1 && _error_validation) {
            setAlertMessage(_error_messages[0])
            setPropertyValidation(_error_validation)
            return
        } else if (_error_messages.length > 1 && _error_validation) {
            setAlertMessage('Error! Please fill in mandatory input!')
            setPropertyValidation(_error_validation)
            return
        }
        // validate property name
        let _checkNameData: any = {
            'name': property.name.trim()
        }
        if (property.id) {
            _checkNameData['id'] = property.id
        }
        postData(`${PROPERTY_CHECK_AVAILABLE_NAME_URL}`, _checkNameData).then(
            response => {
                let _isAvailable = response.data['available']
                if (_isAvailable) {
                    if (property.id) {
                        // if it has property.id, then this is to update property
                        updatePropertyInformation()
                    } else {
                        props.onSave({...property})
                    }
                } else {
                    setAlertMessage(`Error! Property with name ${_checkNameData['name']} already exists! Please choose different name!`)
                }
            }
          ).catch(error => {
            setSavingProperty(false)
            console.log('error ', error)
            alert('Error saving property...')
          })
    }

    return (
        <Grid container className='UploadSection' rowGap={2}>
            <Grid item className='UploadSectionHeader'>
                <span className='UploadSectionHeaderIcon Property'></span>
                <span>Property Information</span>
                <LightTooltip title='Please add the properties name, select open or closed system, and select the property type. Other associated information will be auto-generated by the system.'>
                    <HelpOutlineOutlinedIcon fontSize='small' className='UploadSectionHelpIcon' />
                </LightTooltip>
            </Grid>
            <Grid item className='UploadSectionContent Property'>
                <Grid container flexDirection={'column'} rowGap={2}>
                    <Grid item>
                        <PropertyInfo property={property} enableForm={!savingProperty}
                            onUpdated={(data, validation) => { setProperty(data); setPropertyValidation({...propertyValidation, ...validation}); }}
                            validationError={propertyValidation} />
                    </Grid>
                    <Grid item className='ButtonContainer'>
                        { savingProperty ? (
                                <Button variant='contained' disabled={savingProperty}><CircularProgress size={16} sx={{marginRight: '5px' }}/> SAVING PROPERTY INFORMATION...</Button>
                        ) : (
                            <Button variant='contained' disabled={savingProperty} onClick={onSaveProperty}>SAVE PROPERTY INFORMATION</Button>
                        )}
                    </Grid>
                </Grid>
            </Grid>
            <Grid item>
                <AlertMessage message={alertMessage} onClose={() => setAlertMessage('')} />
            </Grid>
        </Grid>
    )
}
